#! https://zhuanlan.zhihu.com/p/697029148
# 3,4.Disk, Buffers, Files

# 介绍

本节介绍了磁盘和文件，虽然课程名称中有buffers，但并未详细介绍缓冲区。

# Disk and Files

## 1. 设备的时间成本与价格
以下是现代计算机使用的物理存储设备的层次结构。主要的权衡是价格与速度：图表上较高的设备（如缓存`cache`）允许更快的访问，但与慢速设备（如硬盘驱动器`Disk`）相比，每单位数据的生成成本要高得多。
![Image](https://pic4.zhimg.com/80/v2-f29943728a8bde5e313b0662ccdbd983.png)

## 2. Memory and Disk

Memory: 内存，访问此数据相对较快，但一旦数据变得非常大，就不可能将其全部放入内存中。这时需要磁盘（Disk）。

Disk: 磁盘，磁盘是擅长存储大量数据的物理设备，但每当访问数据或写入新数据时，磁盘都会产生巨大的时间成本。

## 3. Files, Pages, Records

关系数据库的基本数据单位是记录`record`（行`row`）。这些记录被组织为关系`relations`（表`table`），并且可以在内存中修改、删除、搜索或创建。

磁盘的基本数据单位是页`page`，从磁盘到内存的最小传输单位。为了以与磁盘兼容的格式表示关系数据库，每个关系都存储在它自己的文件中，并且它的记录被组织成文件中的页面。基于关系的架构和访问模式，数据库将确定：
* （1）使用的文件类型
* （2）如何在文件中组织页面
* （3）如何组织每页上的记录
* （4）如何格式化每个记录

### Choosing File Types

数据库文件 （DB FILE） 是页面的集合，每个页面都包含一组记录。数据库可以跨越文件系统中的多个机器和文件，课程会在分布式事物`Distributed Transactions`中介绍。

文件主要有两种类型：堆文件和已排序文件。对于每个关系，数据库根据关系访问模式的 I/O 成本选择要使用的文件类型。1 I/O 相当于从磁盘读取 1 页或向磁盘写入 1 页，并且根据访问模式中的插入、删除和扫描操作为每个文件类型进行I/O 计算，选择产生较少I/O 成本的文件类型。

排序文件会增加大量的复杂性，以换取可能更快的运行时间。通常，**范围选择和查找在排序文件中更快，而在堆文件中插入、删除和更新更快**。

### Heap File

堆文件是一种对页或页上的记录没有特殊排序的文件类型并且具有两个主要实现。

#### Linked List Implementation

第一个实现是**链表实现**，在链表实现中，每个数据页都包含记录、自由空间跟踪器以及指向下一页和上一页的指针（字节偏移量）。我们有两个链表：一个是完整数据页，另一个是仍有可用空间的页。要在文件中插入一个值，我们可以只遍历空闲页面，停在有足够可用空间支持插入的第一页。对于本课程，我们使用的实现方式的详细信息并不重要。
![Image](https://pic4.zhimg.com/80/v2-30a7caf56fccc9435ea976d287b277a9.png)

#### Page Directory Implementation

第二种类型的堆文件是**页面目录实现**。页面目录实现与链接列表实现的不同之处在于仅对标题页使用链接列表。 每个标题页包含指向下一标题页的指针（字节偏移量），其条目包含指向数据页的指针以及该数据页内剩余的可用空间量。由于标题页的条目存储指向每个数据页的指针，因此数据页本身不再需要存储指向相邻页的指针。
![Image](https://pic4.zhimg.com/80/v2-766ead21b3b6e79fa9844ebd2ddabecd.png)

页面目录相对于链接列表的主要优势是**插入记录通常更快**。要在链接列表实现中找到具有足够空间的页面，可能需要读取标题页和空闲部分中的每个页面。相反，页面目录实现最多只需要读取所有标题页，因为它们包含有关文件中每个数据页上剩余空间的信息。

为了强调这一点，请考虑下面的示例，其中堆文件被实现为链接列表和页目录。每页为 30 个字节，并将一个 20 字节的记录插入到文件中：

* 链表：
![Image](https://pic4.zhimg.com/80/v2-f3480b6640175ae1fe5011b7b028ab91.png)
* 数据页：
![Image](https://pic4.zhimg.com/80/v2-6cf50eecb25df1e20b43db7840baea64.png)

这只是一个小示例，随着页面数量的增加，类似这种情况会导致在链接列表中插入比在页面目录中插入开销大得多。

### Sorted Files

排序文件是一种文件类型，其中页面按顺序排列，每页中的记录按关键字排序。会在B+ Tree中详细介绍。

### 文件成本分析

为了进行有效的查询，我们需要衡量查询的好坏或速度。查询对记录进行操作，这些记录存储在磁盘上文件中的页面上，我们可以使用以下成本模型进行分析：
* $B$ = 文件中的数据块（页）数
* $R$ = 每页的记录数
* $D$ = 读取或写入磁盘页的平均时间（即一个 I/O 的成本）

为了进行分析，我们将使用以下假设：
* 我们最关心的是平均情况。
* 工作负载是均匀随机的。
* 插入和删除对单个记录进行操作。
* 相等选项将只有一个匹配项。
* 堆文件始终插入到文件末尾。
* 排序的文件始终根据搜索键进行排序。
* 打包的文件在删除后被压缩。

在以上假设下进行以下操作的成本：
|操作|堆文件|排序文件|解释|
|--|--|--|--|
|遍历所有记录|$$B*D$$|$$B*D$$|访问所有页，两者相同|
|相等查找|$$B*D / 2$$|$$\log_2(B) * D$$|堆文件平均要访问一半的页才能找到目标文件；排序文件使用折半搜索|
|范围查找|$$B*D$$|$$(\log_2B + Range)*D$$|堆文件需要访问所有的页；排序文件先使用折半搜索找到起始页，然后访问范围内的页|
|插入|$$2D$$|$$(\log_2B + B) * D$$|堆文件访问最后一页，并写入；排序文件先折半搜索找到插入的位置，然后写入|
|删除|$$(B/2 + 1) * D$$|$$(\log_2B + B) * D$$|堆文件先找到删除的位置，然后删除；排序文件先使用折半搜索找到删除的页，然后删除|

## 4. Record

### Record Types

记录类型完全由关系的模式决定，分为两种类型：固定长度记录（FLR）和可变长度记录（VLR）。固定长度记录具有恒定的已知长度。一个例子是整数，它总是有 4 个字节。同时，VLR包含固定长度和可变长度字段（例如：varchar），VLR在可变长度字段之前存储所有固定长度字段，并使用包含指向可变长度字段末尾的指针的记录头。
无论格式如何，每个记录都可以通过其记录id进行唯一标识。

### Page Formats

要实现记录类型，首先，每个数据页都需要一个页眉。此表头包括可用空间、记录数、指针、位图等元数据，以及文件各部分为空的插槽表。

#### FLR

如果记录的长度是固定的，我们可以将它们密集地打包，从而最大限度地提高我们可以在每个页面上存储的数据量，如下图所示。
![Image](https://pic4.zhimg.com/80/v2-a0beeb6474e599ef1bb454c3d6419bf9.png)

如果解包了页面，则页面标题通常存储一个附加的位图，该位图将页面分成插槽和跟踪哪些插槽是打开的或占用的。
![Image](https://pic4.zhimg.com/80/v2-857a318a081d24f4b55169f0fc0b91a4.png)

使用位图时：
* 在标头中保留可用插槽和空插槽的位图（每个插槽一个位，四舍五入到最接近的字节）。
* 若要添加，请在位图中找到一个空槽并将其标记为已填充。
* 要删除，只需将位图引用翻转到 0。不要担心修改数据本身，因为它最终会被覆盖。

#### VLR

可变长度记录与固定长度记录之间的主要区别在于，我们**不再保证每个记录的大小**。为了解决这个问题，每个页都使用一个页脚，该页脚维护一个跟踪插槽计数的插槽目录、一个空闲空间指针和条目。页脚从页面的底部而不是顶部开始，以便在插入记录时插槽目录有空间增长。
![Image](https://pic4.zhimg.com/80/v2-13365691a4f5e6b6af55b918c6a27159.png)

插槽计数跟踪插槽总数。这包括填充槽和空槽。可用空间指针指向页面内的下一个可用位置。插槽目录中的每个条目都由一个[record pointer, record length]对组成。

如果解压缩了页面，则删除涉及在插槽目录中查找记录的条目，并将记录指针和记录长度都设置为空。

