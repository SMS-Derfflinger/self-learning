# 操作系统的组织结构

* Isolation：隔离性是设计操作系统组织结构的驱动力。
* Kernel和User mode：这两种模式用来隔离操作系统内核和用户应用程序。
* System calls：系统调用是你的应用程序能够转换到内核执行的基本方法，这样你的用户态应用程序才能使用内核服务。

# 操作系统隔离性

* 使用操作系统的一个原因，甚至可以说是主要原因就是为了实现多路复用和内存隔离。如果不使用操作系统，并且应用程序直接与硬件交互，就很难实现这两点。
* 接口被精心设计以实现资源的强隔离，通过抽象硬件资源，从而使得提供强隔离性成为可能。
* 为了支持user/kernel mode，处理器会有两种操作模式，第一种是user mode，第二种是kernel mode。
    * 实际上RISC-V还有第三种模式称为machine mode，一般在启动时才会用到

# User/Kernel mode切换

* 是分隔用户空间和内核空间的边界，用户空间运行的程序运行在user mode，内核空间的程序运行在kernel mode。操作系统位于内核空间。
* 要有一种方式可以使得用户的应用程序能够将控制权以一种协同工作的方式转移到内核，这样内核才能提供相应的服务，在RISC-V中有一个专门的指令用来实现这个功能，叫做ECALL。
* 在内核侧，有一个位于syscall.c的函数syscall，每一个从应用程序发起的系统调用都会调用到这个syscall函数，syscall函数会检查ECALL的参数，通过这个参数内核可以知道需要调用的是什么。
* 例如，write系统调用不能直接调用内核中的write代码，而是由封装好的系统调用函数执行ECALL指令。所以write函数实际上调用的是ECALL指令，指令的参数是代表了write系统调用的数字。之后控制权到了syscall函数，syscall会实际调用write系统调用。

# 宏内核 vs 微内核

* 与宏内核对比，在宏内核中如果一个应用程序需要与文件系统交互，只需要完成1次用户空间<->内核空间的跳转，所以微内核的的跳转是宏内核的两倍。通常微内核的挑战在于性能更差。
* XV6是一种宏内核设计，如大多数经典的Unix系统一样。
