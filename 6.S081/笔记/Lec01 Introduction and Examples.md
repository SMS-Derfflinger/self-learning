# 课程内容简介

1. 理解操作系统的设计和实现。
2. 通过XV6获得实际动手经验。

## 操作系统共同的目标

1. 抽象硬件
2. 共享资源
3. 隔离不同的进程
4. 数据实现共享
5. Security
6. 高性能
7. 支持大量不同类型的应用程序

# 操作系统结构

* Kernel是计算机资源的守护者
* 课程中，我们主要关注点在Kernel、连接Kernal和用户空间程序的接口、Kernel内软件的架构
* 应用程序如何访问Kernel：系统调用syscall
    * 系统调用与程序中的函数调用看起来是一样的，但区别是系统调用会实际运行到系统内核中，并执行内核中对于系统调用的实现。

# 系统调用

* 系统调用通常是通过返回-1来表示错误。
* read系统调用
    * 第一个参数是文件描述符，指向一个之前打开的文件。
    * 第二个参数是指向某段内存的指针，程序可以通过指针对应的地址读取内存中的数据，将数据保存在内存中。
    * 第三个参数是代码想读取的最大长度。
    * 返回值可能是读到的字节数，如果到达了文件的结尾没有更多的内容了，read会返回0。如果出现了一些错误，比如文件描述符不存在，read或许会返回-1。

* open系统调用
    * 创建文件描述符。
    * 第一个参数是要创建的文件的名字，例如output.txt。
    * 第二个参数是一些标志位，用来告诉open系统调用在内核中的实现：我们将要创建并写入一个文件。
    * 返回一个新分配的文件描述符，是一个小的数字。

* write系统调用
    * 第一个参数是文件描述符。
    * 第二个参数是数据的指针。
    * 第三个参数是要写入的字节数。

* 内核会为每一个运行进程保存一个表单，表单的key是文件描述符。

* fork系统调用
    * fork会拷贝当前进程的内存，并创建一个新的进程，这里的内存包含了进程的指令和数据。
    * 在两个进程中都会返回，在原始的进程中，fork系统调用会返回大于0的整数，这个是**新创建进程的ID**。而在新创建的进程中，fork系统调用会返回**0**。可以通过返回值的不同区分父子进程。
    * 在Shell中运行东西的时候，Shell实际上会创建一个新的进程来运行输入的每一个指令。

* exec系统调用
    * 从指定的文件中读取并加载指令，并替代当前调用进程的指令。
    * 通常来说exec系统调用不会返回，只会当出错时才会返回。

* wait系统调用
    * 等待之前创建的子进程退出。
    * 参数是一种让退出的子进程以一个整数（32bit的数据）的格式与等待的父进程通信方式。(wait(&status))
    * 会在有一个子进程退出时立即返回，返回结束的子进程的进程号。

* dup系统调用
    * 创建一个新的文件描述符，它与原文件描述符指向相同的文件或资源。
    * 如果成功，dup 返回新创建的文件描述符，它是**最小的未使用**文件描述符。
    * 如果失败，返回 -1，并将 errno 设置为相应的错误代码。

* chdir 系统调用
    * 用于改变调用它的进程的当前工作目录。

* 尽管接口本身是简单的，但是可以将多个接口结合起来形成复杂的用例。比如说创建I/O重定向。
